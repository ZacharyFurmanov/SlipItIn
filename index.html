<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Slip It In</title>
  <style>
    :root { --pad: 14px; --radius: 12px; }
    * { box-sizing: border-box; }
    body { margin: 0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji"; background: #0e0f12; color: #e7e9ea; }
    header { padding: 20px var(--pad); display: flex; align-items: center; justify-content: space-between; border-bottom: 1px solid #23262d; position: sticky; top: 0; background: #0e0f12; z-index: 5; }
    h1 { font-size: 20px; margin: 0; letter-spacing: 0.3px; }
    main { max-width: 980px; margin: 0 auto; padding: 24px var(--pad) 80px; display: grid; gap: 18px; }
    .card { background: #151922; border: 1px solid #23262d; border-radius: var(--radius); padding: 18px; }
    .row { display: flex; gap: 12px; flex-wrap: wrap; align-items: center; }
    input[type="text"] { background: #0f1320; border: 1px solid #2a2e39; color: #e7e9ea; padding: 12px 14px; border-radius: 10px; outline: none; width: 260px; }
    button { padding: 10px 14px; border-radius: 10px; border: 1px solid #2f80ff44; background: #2f80ff22; color: #ebf1ff; cursor: pointer; }
    button[disabled] { opacity: 0.6; cursor: not-allowed; }
    .muted { color: #9aa4b2; }
    .phrase { font-size: 18px; line-height: 1.4; padding: 12px 14px; border-radius: 10px; background: #0f1320; border: 1px dashed #2a2e39; }
    .leader { display: grid; grid-template-columns: 1fr auto; gap: 8px; align-items: center; }
    .leaders { display: grid; gap: 8px; }
    .pill { padding: 6px 10px; border-radius: 999px; background: #0f1320; border: 1px solid #2a2e39; font-size: 12px; }
    .danger { border-color: #ff4d4d66; background: #ff4d4d22; }
    .success { border-color: #2ecc7166; background: #2ecc7122; }
    .notice { border-color: #f1c40f66; background: #f1c40f22; }
    .section-title { margin: 0 0 8px; font-size: 14px; color: #9aa4b2; text-transform: uppercase; letter-spacing: 0.08em; }
    .vote-grid { display: grid; gap: 10px; }
    .small { font-size: 12px; }
    a { color: #7eb5ff; }
    .hidden { display:none; }
  </style>
</head>
<body>
  <header>
    <h1>Slip It In</h1>
    <div id="status" class="pill notice">Not joined</div>
    <div id="errorBox" class="pill danger hidden"></div>
  </header>

  <main>
    <!-- Leaderboard (TOP) -->
    <section class="card">
      <h3 class="section-title">Leaderboard</h3>
      <div id="leaders" class="leaders"></div>
    </section>

    <!-- Join / Name -->
    <section class="card" id="joinCard">
      <h3 class="section-title">Create or Sign In</h3>
      <div class="row">
        <input id="playerName" type="text" placeholder="Username" maxlength="24" />
        <input id="playerPass" type="password" placeholder="Password" />
      </div>
      <div class="row" style="margin-top:8px;">
        <button id="createBtn">Create Account</button>
        <button id="loginBtn" class="notice">Sign In</button>
        <button id="leaveBtn" class="danger" disabled>Leave</button>
      </div>
      <p class="muted small">If cookies clear, just sign in again with your username and password to restore progress.</p>
    </section>

    <!-- Your phrase + action -->
    <section class="card">
      <h3 class="section-title">Your mission</h3>
      <div id="phraseBox" class="phrase muted">Join to receive your phrase‚Ä¶</div>
      <div class="row" style="margin-top:10px;">
        <button id="usedBtn" disabled>üëÄ I used my phrase ‚Äî start vote</button>
        <button id="newPhraseBtn" class="notice" disabled>üîÅ Reroll (if stuck)</button>
      </div>
      <p class="small muted">Reroll uses the next available phrase and returns yours to the pool.</p>
    </section>

    <!-- Voting -->
    <section class="card">
      <h3 class="section-title">Voting</h3>
      <div id="voteArea" class="vote-grid">
        <div class="muted">No active vote.</div>
      </div>
    </section>

    <!-- Admin login (BOTTOM) -->
    <section class="card" id="adminLogin">
      <h3 class="section-title">Admin Login</h3>
      <div class="row">
        <input id="adminPass" type="password" placeholder="Enter admin passcode" />
        <button id="adminLoginBtn">Login</button>
      </div>
      <p class="muted small">Enter passcode to unlock admin tools.</p>
    </section>

    <!-- Admin tools (BOTTOM) -->
    <div id="adminWrapper" class="hidden">
      <section class="card" id="adminCard">
        <h3 class="section-title">Admin</h3>
        <div class="row">
          <button id="seedBtn">Seed phrases from <code>phrases.txt</code></button>
          <button id="resetPhrasesBtn" class="danger">Reset phrases (delete all)</button>
          <span class="muted small">Uploads each line as a phrase document if the pool is empty.</span>
        </div>
      </section>
    </div>
  </main>

  <!-- Firebase SDKs (modular). Replace versions if needed. -->
  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.4/firebase-app.js";
    import { getAuth, signInAnonymously, onAuthStateChanged, updateProfile } from "https://www.gstatic.com/firebasejs/10.12.4/firebase-auth.js";
    import { getFirestore, doc, setDoc, getDoc, addDoc, getDocs, updateDoc, deleteDoc, onSnapshot, query, where, collection, orderBy, limit, serverTimestamp, runTransaction } from "https://www.gstatic.com/firebasejs/10.12.4/firebase-firestore.js";
    import { getAnalytics, isSupported as analyticsSupported } from "https://www.gstatic.com/firebasejs/10.12.4/firebase-analytics.js";

    // ===================== CONFIG =====================
    const firebaseConfig = {
      apiKey: "AIzaSyDkfKCRUpukUKQGRVOzM5Eoe1047oIpkhU",
      authDomain: "slipitin-20a2d.firebaseapp.com",
      projectId: "slipitin-20a2d",
      storageBucket: "slipitin-20a2d.firebasestorage.app",
      messagingSenderId: "129515033223",
      appId: "1:129515033223:web:efded9ef49e9082212de22",
      measurementId: "G-TJY9H34Q2Y"
    };

    const app = initializeApp(firebaseConfig);
    try {
      if (await analyticsSupported()) {
        getAnalytics(app);
      }
    } catch (_) {
      // Analytics not supported in this environment (e.g., not served over HTTPS or unsupported browser). Safe to ignore.
    }
    const auth = getAuth(app);
    const db = getFirestore(app);

    // Game constants
    const ROOM_ID = "default"; // single room for now

    // Elements
    const statusEl = document.getElementById('status');
    const leaveBtn = document.getElementById('leaveBtn');
    const phraseBox = document.getElementById('phraseBox');
    const usedBtn = document.getElementById('usedBtn');
    const newPhraseBtn = document.getElementById('newPhraseBtn');
    const voteArea = document.getElementById('voteArea');
    const leadersEl = document.getElementById('leaders');
    const seedBtn = document.getElementById('seedBtn');
    const adminWrapper = document.getElementById('adminWrapper');
    const adminLoginBtn = document.getElementById('adminLoginBtn');
    const adminPass = document.getElementById('adminPass');
    const playerNameInput = document.getElementById('playerName');
    const playerPassInput = document.getElementById('playerPass');
    const createBtn = document.getElementById('createBtn');
    const loginBtn = document.getElementById('loginBtn');
    // Game identity (username-driven, not Firebase Auth)
    let PLAYER_ID = null; // equals chosen username

    adminLoginBtn.addEventListener('click', () => {
      if (adminPass.value === 'alinaishomo') {
        adminWrapper.classList.remove('hidden');
        document.getElementById('adminLogin').classList.add('hidden');
      } else {
        alert('Incorrect passcode.');
      }
    });

    let currentUser = null; // Firebase user (unused for game identity)
    let myProfile = null;   // players/{username}
    let myPhraseId = null;  // phrases/{id}

    // ===================== AUTH =====================
    onAuthStateChanged(auth, async (u) => {
      if (!u) {
        await signInAnonymously(auth);
        return;
      }
      currentUser = u;
      statusEl.textContent = 'Signed in';
      statusEl.className = 'pill success';
      // No longer restoring by Firebase user
    });

    // ===================== UI HELPERS =====================
    function afterJoinUI(joined) {
      createBtn.disabled = joined;
      loginBtn.disabled = joined;
      leaveBtn.disabled = !joined;
      usedBtn.disabled = !joined;
      newPhraseBtn.disabled = !joined;
      document.getElementById('joinCard').classList.toggle('hidden', joined);
    }

    function setPhraseText(text) {
      phraseBox.textContent = text || 'No phrase yet';
      phraseBox.classList.toggle('muted', !text);
    }

    // ===================== ERROR & CRYPTO HELPERS =====================
    const errorBox = document.getElementById('errorBox');
    function showError(msg) {
      if (!msg) return;
      errorBox.textContent = String(msg);
      errorBox.classList.remove('hidden');
      setTimeout(() => errorBox.classList.add('hidden'), 6000);
      console.error('[SlipItIn]', msg);
    }
    function log(...args) { console.log('[SlipItIn]', ...args); }

    // ===================== PHRASE SEEDING (optional) =====================
    seedBtn.addEventListener('click', async () => {
      try {
        const poolRef = collection(db, 'rooms', ROOM_ID, 'phrases');
        const existing = await getDocs(query(poolRef, limit(1)));
        if (!existing.empty) { alert('Pool already has phrases. Skipping.'); return; }
        const res = await fetch('phrases.txt');
        const text = await res.text();
        const lines = text.split(/\r?\n/).map(s => s.trim()).filter(Boolean);
        if (!lines.length) { alert('phrases.txt is empty'); return; }
        // Batch add (simple loop)
        let i = 0;
        for (const line of lines) {
          await addDoc(poolRef, { phrase: line, assignedTo: null, used: false, createdAt: serverTimestamp() });
          i++;
        }
        alert(`Seeded ${i} phrases.`);
      } catch (e) {
        console.error(e);
        alert('Failed to seed phrases. Ensure phrases.txt is served next to index.html');
      }
    });

    // ===================== JOIN / LEAVE =====================
    async function loadPlayerDoc(name) {
      const pref = doc(db, 'rooms', ROOM_ID, 'players', name);
      const snap = await getDoc(pref);
      return { ref: pref, snap };
    }

    async function createAccount() {
      const name = (playerNameInput.value || '').trim();
      const pass = playerPassInput.value;
      if (!name || !pass) { showError('Enter a username and password'); return; }
      const { ref, snap } = await loadPlayerDoc(name);
      if (snap.exists()) { showError('Username already exists. Pick another.'); return; }
      await setDoc(ref, {
        name,
        password: pass, // plaintext by request
        score: 0,
        active: true,
        phraseId: null,
        createdAt: serverTimestamp(),
        updatedAt: serverTimestamp()
      });
      PLAYER_ID = name;
      localStorage.setItem('slip_player', PLAYER_ID);
      afterJoinUI(true);
      await assignPhraseIfNeeded();
    }

    async function signIn() {
      const name = (playerNameInput.value || '').trim();
      const pass = playerPassInput.value;
      if (!name || !pass) { showError('Enter a username and password'); return; }
      const { ref, snap } = await loadPlayerDoc(name);
      if (!snap.exists()) { showError('Account not found'); return; }
      const data = snap.data();
      if (data.password !== pass) { showError('Incorrect password'); return; }
      await updateDoc(ref, { active: true, updatedAt: serverTimestamp() });
      PLAYER_ID = name;
      localStorage.setItem('slip_player', PLAYER_ID);
      myProfile = data;
      myProfile.active = true;
      myProfile.name = name;
      await hydrateMyPhrase();
      afterJoinUI(true);
    }

    createBtn.addEventListener('click', () => createAccount().catch(showError));
    loginBtn.addEventListener('click', () => signIn().catch(showError));

    // Leave button
    leaveBtn.addEventListener('click', async () => {
      try {
        if (!PLAYER_ID) return;
        await runTransaction(db, async (tx) => {
          const pref = doc(db, 'rooms', ROOM_ID, 'players', PLAYER_ID);
          const psnap = await tx.get(pref);
          if (psnap.exists()) {
            const d = psnap.data();
            if (d.phraseId) {
              const phr = doc(db, 'rooms', ROOM_ID, 'phrases', d.phraseId);
              tx.update(phr, { assignedTo: null });
            }
            tx.update(pref, { active: false, phraseId: null });
          }
        });
        afterJoinUI(false);
        setPhraseText('Sign in to receive your phrase‚Ä¶');
        PLAYER_ID = null;
        localStorage.removeItem('slip_player');
      } catch (e) { showError(e?.message || e); }
    });

    // ===================== ASSIGN / REROLL =====================
    async function hydrateMyPhrase() {
      if (!PLAYER_ID) { setPhraseText('Sign in to get a phrase.'); return; }
      const pref = doc(db, 'rooms', ROOM_ID, 'players', PLAYER_ID);
      const psnap = await getDoc(pref);
      if (psnap.exists()) {
        myProfile = psnap.data();
        myPhraseId = myProfile?.phraseId || null;
        if (myPhraseId) {
          const phrRef = doc(db, 'rooms', ROOM_ID, 'phrases', myPhraseId);
          const phrSnap = await getDoc(phrRef);
          setPhraseText(phrSnap.exists() ? phrSnap.data().phrase : '');
        } else {
          setPhraseText('Click Sign In/Create then press Reroll to get a phrase.');
        }
      } else {
        setPhraseText('Create an account to get a phrase.');
      }
    }

    async function assignPhraseIfNeeded(reroll = false) {
      if (!PLAYER_ID) throw new Error('Not signed in');
      await runTransaction(db, async (tx) => {
        const uref = doc(db, 'rooms', ROOM_ID, 'players', PLAYER_ID);
        const usnap = await tx.get(uref);
        if (!usnap.exists()) throw new Error('Player not found');
        const udata = usnap.data();
        if (reroll && udata.phraseId) {
          tx.update(doc(db, 'rooms', ROOM_ID, 'phrases', udata.phraseId), { assignedTo: null });
          udata.phraseId = null;
        }
        if (udata.phraseId) return; // already have one
        const poolRef = collection(db, 'rooms', ROOM_ID, 'phrases');
        const qSnap = await getDocs(query(poolRef, where('assignedTo', '==', null), limit(1)));
        if (qSnap.empty) throw new Error('No phrases left');
        const pick = qSnap.docs[0];
        tx.update(doc(db, 'rooms', ROOM_ID, 'phrases', pick.id), { assignedTo: PLAYER_ID });
        tx.update(uref, { phraseId: pick.id, updatedAt: serverTimestamp() });
        myPhraseId = pick.id;
      });
      await hydrateMyPhrase();
    }

    newPhraseBtn.addEventListener('click', async () => {
      try { await assignPhraseIfNeeded(true); } catch (e) { showError(e.message); }
    });

    // ===================== VOTING =====================
    usedBtn.addEventListener('click', async () => {
      if (!PLAYER_ID) return showError('Sign in first');
      const voteDoc = doc(db, 'rooms', ROOM_ID, 'state', 'vote');
      await runTransaction(db, async (tx) => {
        const vsnap = await tx.get(voteDoc);
        if (vsnap.exists() && vsnap.data().active) throw new Error('Another vote is already active');
        tx.set(voteDoc, { active: true, candidate: PLAYER_ID, yes: {}, startedAt: serverTimestamp() });
      }).catch(e => showError(e?.message || e));
    });

    // Vote listener
    onSnapshot(doc(db, 'rooms', ROOM_ID, 'state', 'vote'), async (snap) => {
      const data = snap.exists() ? snap.data() : { active: false };
      renderVote(data);
    });

    async function renderVote(v) {
      voteArea.innerHTML = '';
      if (!v.active) {
        voteArea.innerHTML = '<div class="muted">No active vote.</div>';
        return;
      }
      const candidateRef = doc(db, 'rooms', ROOM_ID, 'players', v.candidate);
      const cand = (await getDoc(candidateRef)).data();
      const name = cand?.name || v.candidate;

      const title = document.createElement('div');
      title.innerHTML = `<strong>${name}</strong> claims they slipped it in. Does ${name} pass?`;
      voteArea.appendChild(title);

      // vote button (only if not already voted)
      const alreadyYes = !!v.yes?.[PLAYER_ID];
      const btn = document.createElement('button');
      btn.textContent = alreadyYes ? 'Voted ‚úì' : 'Yes ‚Äî they pass';
      btn.disabled = alreadyYes || !PLAYER_ID;
      btn.addEventListener('click', async () => {
        const voteDoc = doc(db, 'rooms', ROOM_ID, 'state', 'vote');
        await runTransaction(db, async (tx) => {
          const vsnap = await tx.get(voteDoc);
          if (!vsnap.exists()) return;
          const d = vsnap.data();
          d.yes = d.yes || {};
          d.yes[PLAYER_ID] = true;
          tx.update(voteDoc, { yes: d.yes });
        });
      });
      voteArea.appendChild(btn);

      // Compute outcome with active players
      const playersSnap = await getDocs(query(collection(db, 'rooms', ROOM_ID, 'players'), where('active', '==', true)));
      const activeIds = playersSnap.docs.map(d => d.id);
      const yesIds = Object.keys(v.yes || {});
      const unanimous = activeIds.length > 0 && activeIds.every(id => yesIds.includes(id));

      const info = document.createElement('div');
      info.className = 'muted small';
      info.textContent = `Yes votes: ${yesIds.length} / ${activeIds.length} active players`;
      voteArea.appendChild(info);

      if (unanimous) {
        // award point & give new phrase inside a transaction and clear vote
        await runTransaction(db, async (tx) => {
          // increment score
          const uref = doc(db, 'rooms', ROOM_ID, 'players', v.candidate);
          const usnap = await tx.get(uref);
          if (usnap.exists()) {
            const udata = usnap.data();
            tx.update(uref, { score: (udata.score || 0) + 1, updatedAt: serverTimestamp() });
            // return old phrase to used=true and clear from user
            if (udata.phraseId) {
              const pref = doc(db, 'rooms', ROOM_ID, 'phrases', udata.phraseId);
              tx.update(pref, { used: true, assignedTo: null });
              tx.update(uref, { phraseId: null });
            }
          }
          // close vote
          tx.set(doc(db, 'rooms', ROOM_ID, 'state', 'vote'), { active: false, candidate: null, yes: {}, endedAt: serverTimestamp() });
        });
        // assign a new phrase to candidate
        if (PLAYER_ID && PLAYER_ID === v.candidate) {
          await assignPhraseIfNeeded(true); // reroll to get a new one
        }
      }
    }

    // ===================== LIVE LEADERBOARD =====================
    onSnapshot(query(collection(db, 'rooms', ROOM_ID, 'players'), orderBy('score', 'desc')), (snap) => {
      leadersEl.innerHTML = '';
      snap.docs.forEach((d, idx) => {
        const u = d.data();
        const row = document.createElement('div');
        row.className = 'leader';
        row.innerHTML = `<div>${idx+1}. <strong>${u.name || d.id}</strong> ${u.active ? '' : '<span class="pill">(left)</span>'}</div><div class="pill">${u.score || 0}</div>`;
        leadersEl.appendChild(row);
      });
      if (!snap.size) leadersEl.innerHTML = '<div class="muted">No players yet.</div>';
    });

    // When profile changes, keep local state in sync
    onSnapshot(collection(db, 'rooms', ROOM_ID, 'players'), (snap) => {
      if (!PLAYER_ID) return;
      const me = snap.docs.find(d => d.id === PLAYER_ID);
      if (me) { myProfile = me.data(); }
    });

    // ===================== AUTO-RESTORE SESSION =====================
    (async () => {
      const saved = localStorage.getItem('slip_player');
      if (saved) {
        playerNameInput.value = saved;
        PLAYER_ID = saved;
        // Mark active if account exists
        const ref = doc(db, 'rooms', ROOM_ID, 'players', PLAYER_ID);
        const snap = await getDoc(ref).catch(()=>null);
        if (snap && snap.exists()) {
          await updateDoc(ref, { active: true, updatedAt: serverTimestamp() }).catch(()=>{});
          afterJoinUI(true);
          await hydrateMyPhrase();
        }
      }
    })();
  </script>
</body>
</html>
